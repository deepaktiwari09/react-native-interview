
// src/services/payment-gateway/GPayUPIService.ts

/**
 * @file GPayUPIService.ts
 * @description Service layer specifically for triggering Google Pay (GPay) via UPI Intent.
 * This focuses on constructing the `upi://` deeplink to directly invoke GPay for a UPI payment,
 * assuming the necessary transaction details are known or generated by the backend.
 * This is different from GooglePayService.ts which might handle tokenization via Stripe/Braintree or Google Pay SDKs.
 * Note: This relies on the user having GPay installed and set up.
 */

import { Linking, Platform } from 'react-native';

// --- Interview Question: How can you initiate a UPI payment specifically targeting Google Pay from a React Native app? ---
// Discussion points: Constructing a UPI Intent URL (`upi://pay?...`) that includes parameters potentially recognized by GPay,
// or using specific GPay deeplink formats if available and documented (though standard UPI intent is more common).
// Using `Linking.openURL` to trigger the intent.

// --- Interview Question: What information is needed to construct a UPI Intent URL for GPay? ---
// Discussion points:
// - Payee VPA (`pa`): The merchant's Virtual Payment Address.
// - Payee Name (`pn`): The merchant's name.
// - Transaction ID (`tid`): A unique ID generated by your backend for tracking/reconciliation.
// - Transaction Note (`tn`): A brief description of the payment.
// - Amount (`am`): The transaction amount.
// - Currency Code (`cu`): Typically 'INR'.
// - Merchant Code (`mc`): Optional MCC code if applicable.
// - URL (`url`): Optional callback URL (less reliable for status, backend webhook preferred).

const triggerGPayUPIIntent = async (
    payeeVpa: string,
    payeeName: string,
    transactionId: string, // Unique ID from your backend
    amount: string,
    transactionNote: string,
    merchantCode?: string
): Promise<boolean> => {
    if (Platform.OS !== 'android' && Platform.OS !== 'ios') { // UPI intents work on both, but GPay target is implicit
        console.log('UPI Intents are typically used on mobile platforms.');
        return false;
    }

    // Standard UPI Intent URL
    let upiUrl = `upi://pay?pa=${encodeURIComponent(payeeVpa)}` +
                 `&pn=${encodeURIComponent(payeeName)}` +
                 `&tid=${encodeURIComponent(transactionId)}` +
                 `&am=${encodeURIComponent(amount)}` +
                 `&cu=INR` +
                 `&tn=${encodeURIComponent(transactionNote)}`;

    if (merchantCode) {
        upiUrl += `&mc=${encodeURIComponent(merchantCode)}`;
    }

    // Note: While the standard UPI intent allows the OS/user to choose the app,
    // there isn't a universally guaranteed way in the standard `upi://` scheme
    // to *force* only Google Pay to open. Some platforms *might* prioritize it
    // if it's the default or based on heuristics, but relying on this is fragile.
    // Specific GPay deeplinks (`gpay://...`) might exist but are less standardized for payments.
    console.log('Constructed UPI Intent URL (may open GPay or other UPI apps):', upiUrl);

    try {
        // --- Interview Question: How do you check if *any* app can handle the UPI intent before trying to open it? ---
        const supported = await Linking.canOpenURL(upiUrl);

        if (supported) {
            // --- Interview Question: What happens when Linking.openURL is called with a UPI intent? ---
            // Discussion: The OS presents the user with a chooser of installed UPI apps (like GPay, PhonePe, Paytm, BHIM) that can handle the `upi://pay` intent, or opens the default UPI app directly.
            await Linking.openURL(upiUrl);
            console.log('UPI app chooser launched (or default app opened).');
            return true;
        } else {
            console.error('No UPI app is installed or available to handle the payment intent.');
            // --- Interview Question: What should the user experience be if no UPI app is installed? ---
            // Discussion: Show an informative message explaining UPI is needed, potentially link to GPay/BHIM install page. Offer alternative payment methods.
            return false;
        }
    } catch (error) {
        console.error('Error triggering UPI Intent:', error);
        return false;
    }
};

// --- Interview Question: After the user completes the payment in Google Pay (or another UPI app), how does your application get the final status? ---
// Discussion points: Crucially, the UPI Intent flow via `Linking.openURL` does NOT provide a direct callback with the payment status to the originating app.
// Status confirmation MUST rely on:
// 1. Server-to-Server Webhooks: The payment gateway (if used) or the bank notifies your backend. This is the most reliable method.
// 2. Backend Polling: Your app prompts the backend to check the status using the `transactionId`. The backend queries the payment gateway or bank APIs.
// 3. Manual Refresh/Check: User might need to manually refresh the order status in your app.

const checkPaymentStatusOnServer = async (transactionId: string): Promise<'SUCCESS' | 'PENDING' | 'FAILURE' | 'UNKNOWN'> => {
    console.log(`Checking payment status on server for Txn ID: ${transactionId}`);
    // This function simulates the app asking *your* backend for the status.
    // Your backend would then need to implement the actual status check logic
    // (e.g., querying PayU, Paytm, Cashfree, or bank APIs if doing direct UPI integration).
    try {
        // const response = await fetch(`/api/payment/status/${transactionId}`);
        // const data = await response.json();
        // if (!response.ok) throw new Error('Status check failed');
        // return data.status; // e.g., 'SUCCESS', 'PENDING', 'FAILURE'

        // Placeholder simulation
        const statuses: Array<'SUCCESS' | 'PENDING' | 'FAILURE'> = ['SUCCESS', 'PENDING', 'FAILURE'];
        const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
        console.log('Mock Server Status for Txn ID:', randomStatus);
        return randomStatus;
    } catch (error) {
        console.error('Error checking payment status on server:', error);
        return 'UNKNOWN';
    }
};

// --- Interview Question: What are the limitations or challenges of using the UPI Intent flow compared to a full SDK integration? ---
// Discussion points:
// - No Direct Status Callback: Reliant on backend webhooks/polling for confirmation.
// - App Switching: User leaves your app to complete payment. Need to handle app resume gracefully.
// - No Control Over UPI App Choice: User selects the app (unless a specific deeplink is used, which is less standard).
// - Error Handling: Limited insight into *why* a payment failed within the UPI app itself.
// - Reconciliation: Backend needs robust tracking using the unique `transactionId`.

export const GPayUPIService = {
  triggerGPayUPIIntent,
  checkPaymentStatusOnServer, // Simulates client polling backend
};

// --- General Interview Questions ---
// - Explain the difference between a VPA (Virtual Payment Address) and a UPI ID. (Generally synonymous).
// - What is the role of NPCI in the UPI ecosystem?
// - Can you use UPI Intents for recurring payments? (Generally no, UPI mandates/autopay have separate flows, often requiring SDKs or specific gateway integrations).
// - How would you test UPI Intent payments? (Using test VPAs/environments if provided by gateway, testing with actual UPI apps in sandbox modes if available, or carefully in production with small amounts).
